<p><link rel="stylesheet" type="text/css" href="style.css"></link></p>

<script type="text/javascript" src="http://code.jquery.com/jquery-latest.min.js"></script>
<link rel="stylesheet" href="fancybox/source/jquery.fancybox.css" type="text/css" media="screen" />
<script type="text/javascript" src="fancybox/source/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
    $(document).ready(function() {
        $('.galleryTable').each(function(index, elem){
            $('img', elem).wrap(function() {
                return '<a class="fancybox" rel="gal' + index + '" href="' + $(this).prop('src') + '" title="' + $(this).prop('title') + '">' + $(this).html() + '</a>';
            });
        });

        $('.fancybox').not("[rel^='gal']").wrap(function() {
            return '<a class="fancybox" href="' + $(this).prop('src') + '" title="' + $(this).prop('title') + '">' + $(this).html() + '</a>';
        });
        $(".fancybox").fancybox({
            openEffect  : 'elastic',
            closeEffect : 'elastic',

            helpers : {
                title : {
                    type : 'inside'
                }
            }
        });
    });
</script>

<h1>Security Assessment of Scorecenter</h1>

<p>Prepared by <a href="http://gjoseph92.github.io">Gabe Joseph</a> &bull; 4/30/2013</p>

<h2>Introduction</h2>

<p>This assessment tests the security of the <a href="http://blooming-cliffs-4876.herokuapp.com/">ScoreCenter</a> web application developed by <a href="http://pattra.github.io/">@pattra</a> for <a href="http://tuftsdev.github.io/WebProgramming/assignments/a5.html">Comp20 assignment 5</a>. According to the specifications she followed from <em>her</em> client, ScoreCenter is "a web application that maintains high scores for HTML5 games" by providing an API for other developers to submit and retrieve the scores their games produce. It also offers a web interface where users can see all scores submitted, and search for scores by username. However, vulnerabilities in the application currently make it unsuitable for public use, so this document finds those vulnerabilities and suggests solutions for them.</p>

<p><strong>What counts as a vulnerability?</strong> That's a tough question, because my client's client's (or <code>client**</code>; many levels of client-indirection here) specifications demanded inherent insecurities. Most importantly, authentication is neither required nor allowed in the submission API specification, so anyone can submit a high score for any game under any username, with any score amount (which makes the highness of a "high score" dubious). At the least, implementing an API key, so each game accepts submissions from only certain developers, would be necessary to ensure the data is valid. Therefore, this assessment focuses mainly on vulnerabilities in the code, not how the API can be (ab)used with false submissions, which is arguably the biggest insecurity of all.</p>

<h2>Methodology</h2>

<p>Testing was first carried out "black-box", using just what would be available to an attacker. However, I ran all code locally, and therefore did have to modify it slightly to connect to a local mongo instance and not Heroku's. Using just simple tools (<code>curl</code> and an HTML form I'd previously written to test my own code), I found multiple vulnerabilities. I then reviewed the code to look for possible logic errors or opportunities for server-side exploitation.</p>

<h2>Abstract of Findings</h2>

<h2>Issues Found</h2>

<ol>
<li><p><strong>Cross-Cross-Site Scripting</strong></p>

<ul>
<li>Affects GET API</li>
<li><span class="mod">Moderate</span>: though a nuisance for clients, this issue is at least easily-resolvable, and offending submissions can also be fixed retroactively.</li>
<li>Data submitted via the POST API is not escaped, so it could include JavaScript or HTML (in place of a username or score) that a client's application would execute if it didn't include its own escaping. Though XSS is avoided on the web interface by escaping brackets (no <code>&lt;script&gt;</code>) and ampersands (<code>&amp;#x3C;</code> won't produce <code>&lt;</code>), an attacker can use ScoreCenter to attack a client's code. For example, running <code>curl --data "game_title=frogger&amp;username=&lt;iframe src='http://omfgdogs.com'&gt;&lt;/iframe&gt;&amp;score=1000000" localhost:3000/submit.json</code> will not inject the amusing iframe into the ScoreCenter web interface, but might affect an unsuspecting client:
<table class="galleryTable">
<tr><td><img src="img/pre-xss-client.png" alt="pre-injection" title="Client site before injection" /></td>
<td><img src="img/post-xss-client.png" alt="post-injection" title="Client site after injection" /></td></tr>
</table></li>
<li>This issue can be resolved by escaping user input before it enters the database. For example, commonly-dangerous characters can be escaped to their HTML-code equivalents, then the input can be filtered through a whitelist of allowable characters (such as <code>str.match(/[\d\w\s\]|[\~\!\@\#\$\^\*\-\_\+\;]*/g).join('');</code>.</li>
</ul></li>
<li><p><strong>Server crash on invalid JSON</strong></p>

<ul>
<li>Affects GET API</li>
<li><span class="mod">Moderate</span>: a simple attack can crash the Node web server, but the vulnerability is very easily resolvable</li>
<li>As noted before, the data submitted is not escaped. Therefore, an attacker can submit data that results in malformed JSON (such as extra <code>,</code> or <code>"</code> characters), which makes the JSON parser throw an uncaught exception. Though escaping input of such characters might eliminate the symptom, the real problem is the convoluted code for the <code>/highscores.json</code> route. Rather than letting Express handle the JSONifying of the JavaScript object that results from a MongoDB query, the function tries to make JSON manually by string concatenation. However, in the final line, that string is parsed <em>back</em> into an object by <code>JSON.parse()</code>, which is given to Express to send as the response. (Which, of course, is converted to a string again by Express via <code>JSON.stringify()</code>.) Therefore, if the strings concatenated contain JSON characters (<code>{</code>, <code>"</code>, etc.), the parser will throw an exception, which ends the server:
<table class="galleryTable">
<tr><td><img src="img/malformed-submit.png" alt="Malformed data" title="Malformed data submitted via POST" /></td>
<td><img src="img/malformed-get.png" alt="GET crashes server" title="GETting the highscores crashes the server" /></td>
<td><img src="img/malformed-log.png" alt="Server log" title="The unexpected character causes an exception" /></td></tr>
</table></li>
<li>This issue <em>could</em> be resolved by just wrapping <code>JSON.parse(strJson)</code> in a try/catch block. However, it <em>should</em> be resolved by removing the lengthy string-concatenation part, and just sending the array of results returned by Mongo directly through Express, which JSONifies it automatically. (No need for the <code>strJson</code> part, just call <code>response.send(docs)</code> after sorting.)</li>
<li><p><strong>Sidenote</strong>: though not a security flaw, I did notice that the scores aren't sorted correctly: <code>/highscores.json</code> gives the <em>latest 10 scores</em> in sorted order, not the top 10 ever. This should be resolved by using a Mongo parameter to sort:</p>

<pre><code>collection.find( { game_title : sanitize(req.query.game_title) }, {
        sort : { score : -1 },
        limit : 10,
    } ).toArray(function(err, docs) {
        response.send(docs);
    });
</code></pre></li>
</ul></li>
<li><p><strong>Injection of additional database fields</strong></p>

<ul>
<li>In POST API; affects database only</li>
<li><span class="low">Low</span>: Arbitrary fields can be included in the database, but they are not currently returned by the GET API, so the only cost is in extra database space and lookups.</li>
<li>By reviewing the code for the <code>/submit.json</code> route, I found that so long as the submission has the required fields, the entire submission body is added to the database by <code>collection.insert(request.body, ...</code>, including any extraneous fields. Because the <code>/highscores.json</code> code picks fields by name, these extra fields won't come back to a client, but they still take up space in the database.
<table class="galleryTable">
<tr><td><img src="img/extra-field-curl.png" alt="Inserting extra fields" title="Submitting extra fields via POST" /></td>
<td><img src="img/extra-field-mongo.png" alt="Server log" title="All fields are stored in Mongo, including extras" /></td></tr>
</table></li>
</ul></li>
<li><p><strong>Arbitrary queries and JavaScript execution on Mongo</strong></p>

<ul>
<li>In user search; affects everything</li>
<li><span class="low">High</span>: Given that the <em>least</em> bad thing an attacker could do is perform any query possible on the database, this is serious. However, it is also easy to resolve.</li>
<li><p>Reviewing the code for user search, I noticed that the user to look up is a GET parameter, but the Mongo search executes whatever that query is: <code>var cursor = collection.find(request.query);</code>, making anyone able to run any query against the database (and see the results in a pretty table view!) just by passing their query as a parameter. If the database contained private information, this would be a massive security flaw; as it is, all data is publicly available on the homepage. However, using MongoDB's <code>$where</code>, <code>mapReduce</code>, and <code>group</code> queries, attackers can execute (limited) JavaScript on the database. Modifying the data isn't possible, but a crude DoS attack can lock up the database with executing a meaningless query:</p>

<pre><code>{ $where: function() {
    while(true) {}
}}
</code></pre></li>
</ul></li>
</ol>
